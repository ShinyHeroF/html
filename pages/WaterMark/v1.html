<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport"content="width=device-width,initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <p style="height: 100vh">这是文件内容!!!</p>
    <script>
      const addWatermark = (watermarkContainer) => {
        const rotate = 45;
        const gap = 100;
        const text = "水印";
        const fontSize = 14;
        const color = "rgba(0,0,0,0.3)";

        const canvas = document.createElement("canvas" );
        const context = canvas.getContext("2d");
        const font = fontSize + "px Arial";
        // 设置水印文字的宽度和高度
        const metrics = context.measureText(text);
        const canvasWidth = metrics.width + gap;
        canvas.width = canvasWidth;

        canvas.height = canvasWidth;
        // 绘制水印文字
        context.translate(canvas .width / 2, canvas.height / 2);
        context.rotate((-1 * rotate * Math.PI) / 180);
        context.fillStyle = color;
        context.font = font;
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(text,0,0);
        // 将canvas转为图片
        const url = canvas.toDataURL("image/png");
        // 创建水印元素并添加到容器中
        const watermarkLayer = document.createElement("div");
        watermarkLayer.style.position = "absolute";
        watermarkLayer.style.top = "0";
        watermarkLayer.style.left = "0";
        watermarkLayer.style.width = "100%";
        watermarkLayer.style.height="100%";
        watermarkLayer.style.pointerEvents = "none";
        watermarkLayer.style.backgroundImage = `url(${url})`;
        watermarkLayer.style.backgroundRepeat = "repeat";
        watermarkLayer.style.zIndex = "9999";
        watermarkContainer.appendChild(watermarkLayer);
        return watermarkLayer;
      };

      const watermarkContainer = document.querySelector("body");
      watermarkLayer = addWatermark(watermarkContainer);

      const ob = new MutationObserver((mutations )=>{
      if (mutations.length === 0) return;
        mutations.forEach((mutation) => {
          if (mutation.type === "childList") {
            // 从删除元素中查找是否包含用于展示水印的元素
            Array.from(mutation.removedNodes).filter((item) => item === watermarkLayer).forEach((item) => {
              console.log("水印被移除了，重新加回去");
              // 如果包含水印元素，则将水印元素重新加回去，并更新 watermarkLayer 方便下次判断
              watermarkLayer = addWatermark(watermarkContainer);
            });
          } else if (mutation.type ==="attributes") {
            // 当前修改的元素是水印元素，由于水印元素在生成之后几乎不会改变，
            // 因此我们甚至都无需判断是否改变的是style 了
            // 只要水印元素的任意属性被二次修改了，我们就重置水印
            if (mutation.target === watermarkLayer) {
              console.log("水印样式被修改了，重新加回去");
              watermarkContainer.removeChild(watermarkLayer);
              watermarkLayer = addWatermark(watermarkContainer);
            }
          }
        });
      });
      ob.observe(watermarkContainer,{
        childList: true,
        subtree: true,
        attributes: true,
      });
      // addWatermark(watermarkContainer);
    </script>
  </body>
</html>